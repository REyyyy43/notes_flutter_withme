1. ¿Qué es la arquitectura de código limpio?
La Arquitectura de Código Limpio es un patrón de diseño de software propuesto por Robert C. Martin (también conocido como Tío Bob).

El objetivo principal de la Arquitectura de Código Limpio es garantizar la separación de responsabilidades . 

Divide el sistema en capas , cada una con una responsabilidad distinta. Estas capas incluyen:



-Capa de presentación (interfaz de usuario)

-Capa de dominio (lógica de negocio)

-Capa de datos (Fuentes de datos)



La arquitectura garantiza que la lógica de negocio esté aislada de dependencias externas como marcos de interfaz de usuario, 

bases de datos o bibliotecas de red, lo que hace que su código sea más flexible, reutilizable y fácil de probar .

Principios clave de la arquitectura limpia


Separación de responsabilidades : Diferentes partes del código deben manejar diferentes responsabilidades.

Independencia : La lógica empresarial principal debe ser independiente de la interfaz de usuario, las fuentes de datos o cualquier marco externo.

Facilidad de prueba : Dado que la lógica de negocio está desacoplada de los elementos externos, resulta más fácil escribir pruebas unitarias para ella.




2. ¿Por qué usar una arquitectura de código limpio en Flutter?

Si bien Flutter permite un desarrollo rápido de la interfaz de usuario, la Arquitectura Limpia ayuda a gestionar la complejidad en aplicaciones más grandes. 

Estas son algunas razones para usar la Arquitectura de Código Limpio en Flutter:


-Mantenibilidad : La separación de responsabilidades garantiza que los cambios en una capa no afecten a las demás.


-Escalabilidad : A medida que tu aplicación crece, 

la Arquitectura Limpia facilita la extensión de funcionalidades sin necesidad de refactorizar grandes partes del código base.


-Facilidad de prueba : Al aislar la lógica de negocio, 

puede escribir pruebas unitarias significativas sin depender de la interfaz de usuario ni de las fuentes de datos.




3. Capas de la arquitectura de código limpio

En la arquitectura de código limpio, existen tres capas principales:


1. Capa de dominio (El núcleo)

Este es el núcleo de tu solicitud . Contiene:

Entidades : Clases Dart simples que representan modelos de negocio.

Casos de uso : Interactores que encapsulan la lógica y las reglas de negocio.

Repositorios : Contratos abstractos que definen cómo se obtendrán los datos.



2. Capa de datos

Esta capa gestiona las fuentes de datos e implementa las interfaces del repositorio definidas en la capa de dominio. Incluye:

-Modelos de datos : Clases que representan los datos obtenidos de las API o de las bases de datos locales.

-Fuentes de datos : Implementaciones para solicitudes de red, bases de datos locales, etc.

-Implementación del repositorio : Implementaciones concretas del repositorio.



3. Capa de presentación

Esta capa contiene la lógica de la interfaz de usuario y la gestión del estado .

 Aquí es donde se integra el patrón BLoC . 

 Utilizamos BLoC para gestionar el estado e interactuar con los casos de uso de la capa de dominio.



 4. Introducción al patrón BLoC

BLoC (Componente de Lógica de Negocio) es un patrón de gestión de estado que facilita la separación de la lógica de presentación de la lógica de negocio en una aplicación Flutter. 

Los componentes clave del patrón BLoC son:

Eventos : Acciones que el usuario o el sistema desencadenan.

Estados : El estado de la interfaz de usuario en función de los eventos.

BLoC : Gestiona la lógica de negocio asignando eventos a estados.

La principal ventaja de BLoC es que permite desacoplar la interfaz de usuario de la lógica. 

BLoC escucha eventos (como pulsaciones de botones) y emite nuevos estados que la interfaz de usuario puede detectar.



5. ¿Por qué BLoC con arquitectura limpia?

El uso de BLoC con Clean Architecture garantiza una clara separación entre la interfaz de usuario y la lógica de negocio , 

lo que facilita las pruebas y el mantenimiento del código. 

BLoC se encarga de gestionar las transiciones de estado y las reglas de negocio, 

mientras que las capas de Clean Architecture aseguran que BLoC interactúe únicamente con las partes necesarias del código fuente, 

como los casos de uso y los repositorios.



6. Creación de una aplicación Flutter utilizando Clean Architecture y BLoC

Ahora, vamos a crear una aplicación Flutter usando Clean Architecture y BLoC. 

Crearemos una aplicación sencilla que obtenga los datos de un usuario desde una API y los muestre en la pantalla.


Estructura del proyecto

lib/
├── data/
│   ├── models/
│   ├── repositories/
│   └── datasources/
├── domain/
│   ├── entities/
│   └── usecases/
├── presentation/
│   ├── bloc/
│   └── screens/
└── main.dart

Implementación de la capa de dominio

Primero, definamos el UserEntityy UserRepository.


// domain/entities/user_entity.dart

-------------------------
class UserEntity {
  final String id;
  final String name;

  UserEntity({required this.id, required this.name});
}

// domain/repositories/user_repository.dart
abstract class UserRepository {
  Future<UserEntity> getUser(String userId);
}
---------------------------


A continuación, cree el elemento GetUserUseCasepara encapsular la lógica de negocio.


// domain/usecases/get_user_usecase.dart

-------------------------------------
class GetUserUseCase {
  final UserRepository repository;

  GetUserUseCase(this.repository);

  Future<UserEntity> execute(String userId) {
    return repository.getUser(userId);
  }
}
---------------------------------------



Implementación de la capa de datos

Defina UserModele implemente el repositorio.

// data/models/user_model.dart

-------------------------------------------------------
class UserModel {
  final String id;
  final String name;

  UserModel({required this.id, required this.name});

  factory UserModel.fromJson(Map<String, dynamic> json) {
    return UserModel(
      id: json['id'],
      name: json['name'],
    );
  }
}
----------------------------------------------------------


// data/repositories/user_repository_impl.dart

-----------------------------------------------------------
class UserRepositoryImpl implements UserRepository {
  final RemoteDataSource remoteDataSource;

  UserRepositoryImpl(this.remoteDataSource);

  @override
  Future<UserEntity> getUser(String userId) async {
    final userModel = await remoteDataSource.fetchUser(userId);
    return UserEntity(id: userModel.id, name: userModel.name);
  }
}
--------------------------------------------------------------


Implemente el protocolo RemoteDataSourcepara solicitudes de red.


// data/datasources/remote_data_source.dart

----------------------------------------------------------
class RemoteDataSource {
  Future<UserModel> fetchUser(String userId

) async {
    // Fake network request for simplicity
    await Future.delayed(Duration(seconds: 2));
    return UserModel(id: userId, name: 'John Doe');
  }
}
----------------------------------------------------------


Implementación de la capa de presentación (BLoC)

Crea el UserBlocsistema para gestionar el estado.

// presentation/bloc/user_bloc.dart

------------------------------------------------------------------
class UserBloc extends Bloc<UserEvent, UserState> {
  final GetUserUseCase getUserUseCase;

  UserBloc(this.getUserUseCase) : super(UserInitial());

  @override
  Stream<UserState> mapEventToState(UserEvent event) async* {
    if (event is GetUserEvent) {
      yield UserLoading();
      try {
        final user = await getUserUseCase.execute(event.userId);
        yield UserLoaded(user);
      } catch (e) {
        yield UserError("Couldn't fetch user");
      }
    }
  }
}
-------------------------------------------------------------------------

Implementación de la interfaz de usuario

Ahora, implemente la interfaz de usuario BlocBuilderpara escuchar los cambios de estado.



// presentation/screens/user_screen.dart

----------------------------------------------------------------------------------------------
class UserScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('User Profile')),
      body: BlocProvider(
        create: (context) => UserBloc(GetUserUseCase(UserRepositoryImpl(RemoteDataSource()))),
        child: UserProfile(),
      ),
    );
  }
}

class UserProfile extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return BlocBuilder<UserBloc, UserState>(
      builder: (context, state) {
        if (state is UserInitial) {
          return Center(child: Text('Press the button to fetch user data.'));
        } else if (state is UserLoading) {
          return Center(child: CircularProgressIndicator());
        } else if (state is UserLoaded) {
          return Center(child: Text('User: ${state.user.name}'));
        } else if (state is UserError) {
          return Center(child: Text(state.message));
        }
        return Container();
      },
    );
  }
}
--------------------------------------------------------------------------------------



7. Ejemplo de código completo

Aquí tenéis el código completo de esta aplicación con Clean Architecture y BLoC en Flutter:

dardo principal

--------------------
void main() {
  runApp(MaterialApp(
    home: UserScreen(),
  ));
}
---------------------


8. Prueba de la arquitectura

Una de las ventajas de la Arquitectura Limpia es la facilidad de prueba . Escribamos pruebas unitarias para GetUserUseCaseasegurarnos de que la lógica de negocio funciona como se espera.

------------------------------------------------------------------
void main() {
  final mockUserRepository = MockUserRepository();
  final getUserUseCase = GetUserUseCase(mockUserRepository);

  test('should return user when called with a valid ID', () async {
    // Arrange
    final user = UserEntity(id: '1', name: 'John Doe');
    when(mockUserRepository.getUser(any)).thenAnswer((_) async => user);

    // Act
    final result = await getUserUseCase.execute('1');

    // Assert
    expect(result, user);
  });
}
-------------------------------------------------------------------------

9. Mejores prácticas y consejos avanzados

Utilice la inyección de dependencias : Considere usar un paquete como get_itpara administrar las dependencias de manera escalable.

Evite el acoplamiento excesivo : Asegúrese siempre de que su lógica de negocio no dependa de frameworks externos como Flutter, API o bases de datos.

Separación de capas : Asegúrese de que la interfaz de usuario, la lógica empresarial y los datos se mantengan en capas separadas para mantener una arquitectura limpia.

